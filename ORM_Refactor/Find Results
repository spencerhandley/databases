Searching 1436 files for "executing"

/Users/student/Desktop/2014-09-databases/client/bower_components/jquery/jquery.js:
  766  					fn = null;
  767
  768: 				// ...except when executing function values
  769  				} else {
  770  					bulk = fn;

/Users/student/Desktop/2014-09-databases/client/bower_components/jquery/src/core.js:
  746  					fn = null;
  747
  748: 				// ...except when executing function values
  749  				} else {
  750  					bulk = fn;

/Users/student/Desktop/2014-09-databases/client/bower_components/jquery/test/unit/core.js:
  608  	ok( !jQuery["foo"], "Make sure the script wasn't executed prematurely" );
  609  	jQuery("body").append("<script>jQuery.foo='test';</script>");
  610: 	ok( jQuery["foo"], "Executing a scripts contents in the right context" );
  611
  612  	// Test multi-line HTML

/Users/student/Desktop/2014-09-databases/node_modules/chai/chai.js:
 3527   *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 3528   *
 3529:  * The result can then be used as both a method assertion, executing both `method` and
 3530   * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 3531   *

/Users/student/Desktop/2014-09-databases/node_modules/chai/lib/chai/utils/addChainableMethod.js:
   43   *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
   44   *
   45:  * The result can then be used as both a method assertion, executing both `method` and
   46   * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
   47   *

/Users/student/Desktop/2014-09-databases/node_modules/mocha/mocha.js:
 4672          self.failHook(hook, err);
 4673
 4674:         // stop executing hooks, notify callee of hook err
 4675          return fn(err);
 4676        }

/Users/student/Desktop/2014-09-databases/node_modules/mocha/lib/runner.js:
  263          self.failHook(hook, err);
  264
  265:         // stop executing hooks, notify callee of hook err
  266          return fn(err);
  267        }

/Users/student/Desktop/2014-09-databases/node_modules/mysql/package.json:
   48      "test-travis": "node test/run-cov.js lcovonly"
   49    },
   50:   "readme": "# mysql\n\n[![NPM Version][npm-image]][npm-url]\n[![NPM Downloads][downloads-image]][downloads-url]\n[![Node.js Version][node-version-image]][node-version-url]\n[![Build Status][travis-image]][travis-url]\n[![Test Coverage][coveralls-image]][coveralls-url]\n\n## Install\n\n```sh\n$ npm install mysql\n```\n\nFor information about the previous 0.9.x releases, visit the [v0.9 branch][].\n\nSometimes I may also ask you to install the latest version from Github to check\nif a bugfix is working. In this case, please do:\n\n```sh\n$ npm install felixge/node-mysql\n```\n\n[v0.9 branch]: https://github.com/felixge/node-mysql/tree/v0.9\n\n## Introduction\n\nThis is a node.js driver for mysql. It is written in JavaScript, does not\nrequire compiling, and is 100% MIT licensed.\n\nHere is an example on how to use it:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'me',\n  password : 'secret'\n});\n\nconnection.connect();\n\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n\n  console.log('The solution is: ', rows[0].solution);\n});\n\nconnection.end();\n```\n\nFrom this example, you can learn the following:\n\n* Every method you invoke on a connection is queued and executed in sequence.\n* Closing the connection is done using `end()` which makes sure all remaining\n  queries are executed before sending a quit packet to the mysql server.\n\n## Contributors\n\nThanks goes to the people who have contributed code to this module, see the\n[GitHub Contributors page][].\n\n[GitHub Contributors page]: https://github.com/felixge/node-mysql/graphs/contributors\n\nAdditionally I'd like to thank the following people:\n\n* [Andrey Hristov][] (Oracle) - for helping me with protocol questions.\n* [Ulf Wendel][] (Oracle) - for helping me with protocol questions.\n\n[Ulf Wendel]: http://blog.ulf-wendel.de/\n[Andrey Hristov]: http://andrey.hristov.com/\n\n## Sponsors\n\nThe following companies have supported this project financially, allowing me to\nspend more time on it (ordered by time of contribution):\n\n* [Transloadit](http://transloadit.com) (my startup, we do file uploading &\n  video encoding as a service, check it out)\n* [Joyent](http://www.joyent.com/)\n* [pinkbike.com](http://pinkbike.com/)\n* [Holiday Extras](http://www.holidayextras.co.uk/) (they are [hiring](http://join.holidayextras.co.uk/vacancy/software-engineer/))\n* [Newscope](http://newscope.com/) (they are [hiring](http://www.newscope.com/stellenangebote))\n\nIf you are interested in sponsoring a day or more of my time, please\n[get in touch][].\n\n[get in touch]: http://felixge.de/#consulting\n\n## Community\n\nIf you'd like to discuss this module, or ask questions about it, please use one\nof the following:\n\n* **Mailing list**: https://groups.google.com/forum/#!forum/node-mysql\n* **IRC Channel**: #node.js (on freenode.net, I pay attention to any message\n  including the term `mysql`)\n\n## Establishing connections\n\nThe recommended way to establish a connection is this:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'example.org',\n  user     : 'bob',\n  password : 'secret'\n});\n\nconnection.connect(function(err) {\n  if (err) {\n    console.error('error connecting: ' + err.stack);\n    return;\n  }\n\n  console.log('connected as id ' + connection.threadId);\n});\n```\n\nHowever, a connection can also be implicitly established by invoking a query:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection(...);\n\nconnection.query('SELECT 1', function(err, rows) {\n  // connected! (unless `err` is set)\n});\n```\n\nDepending on how you like to handle your errors, either method may be\nappropriate. Any type of connection error (handshake or network) is considered\na fatal error, see the [Error Handling](#error-handling) section for more\ninformation.\n\n## Connection options\n\nWhen establishing a connection, you can set the following options:\n\n* `host`: The hostname of the database you are connecting to. (Default:\n  `localhost`)\n* `port`: The port number to connect to. (Default: `3306`)\n* `localAddress`: The source IP address to use for TCP connection. (Optional)\n* `socketPath`: The path to a unix domain socket to connect to. When used `host`\n  and `port` are ignored.\n* `user`: The MySQL user to authenticate as.\n* `password`: The password of that MySQL user.\n* `database`: Name of the database to use for this connection (Optional).\n* `charset`: The charset for the connection. This is called \"collation\" in the SQL-level\n  of MySQL (like `utf8_general_ci`). If a SQL-level charset is specified (like `utf8mb4`)\n  then the default collation for that charset is used. (Default: `'UTF8_GENERAL_CI'`)\n* `timezone`: The timezone used to store local dates. (Default: `'local'`)\n* `connectTimeout`: The milliseconds before a timeout occurs during the initial connection\n  to the MySQL server. (Default: 10 seconds)\n* `stringifyObjects`: Stringify objects instead of converting to values. See\nissue [#501](https://github.com/felixge/node-mysql/issues/501). (Default: `'false'`)\n* `insecureAuth`: Allow connecting to MySQL instances that ask for the old\n  (insecure) authentication method. (Default: `false`)\n* `typeCast`: Determines if column values should be converted to native\n   JavaScript types. (Default: `true`)\n* `queryFormat`: A custom query format function. See [Custom format](#custom-format).\n* `supportBigNumbers`: When dealing with big numbers (BIGINT and DECIMAL columns) in the database,\n  you should enable this option (Default: `false`).\n* `bigNumberStrings`: Enabling both `supportBigNumbers` and `bigNumberStrings` forces big numbers\n  (BIGINT and DECIMAL columns) to be always returned as JavaScript String objects (Default: `false`).\n  Enabling `supportBigNumbers` but leaving `bigNumberStrings` disabled will return big numbers as String\n  objects only when they cannot be accurately represented with [JavaScript Number objects] (http://ecma262-5.com/ELS5_HTML.htm#Section_8.5)\n  (which happens when they exceed the [-2^53, +2^53] range), otherwise they will be returned as\n  Number objects. This option is ignored if `supportBigNumbers` is disabled.\n* `dateStrings`: Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then\n   inflated into JavaScript Date objects. (Default: `false`)\n* `debug`: Prints protocol details to stdout. (Default: `false`)\n* `trace`: Generates stack traces on `Error` to include call site of library\n   entrance (\"long stack traces\"). Slight performance penalty for most calls.\n   (Default: `true`)\n* `multipleStatements`: Allow multiple mysql statements per query. Be careful\n  with this, it exposes you to SQL injection attacks. (Default: `false`)\n* `flags`: List of connection flags to use other than the default ones. It is\n  also possible to blacklist default ones. For more information, check\n  [Connection Flags](#connection-flags).\n* `ssl`: object with ssl parameters or a string containing name of ssl profile. See [SSL options](#ssl-options).\n\n\nIn addition to passing these options as an object, you can also use a url\nstring. For example:\n\n```js\nvar connection = mysql.createConnection('mysql://user:pass@host/db?debug=true&charset=BIG5_CHINESE_CI&timezone=-0700');\n```\n\nNote: The query values are first attempted to be parsed as JSON, and if that\nfails assumed to be plaintext strings.\n\n### SSL options\n\nThe `ssl` option in the connection options takes a string or an object. When given a string,\nit uses one of the predefined SSL profiles included. The following profiles are included:\n\n* `\"Amazon RDS\"`: this profile is for connecting to an Amazon RDS server and contains the\r\n  ca from https://rds.amazonaws.com/doc/rds-ssl-ca-cert.pem\r\n\r\nWhen connecting to other servers, you will need to provide an object of options, in the\nsame format as [crypto.createCredentials](http://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details).\nPlease note the arguments expect a string of the certificate, not a file name to the\ncertificate. Here is a simple example:\n\n```js\nvar connection = mysql.createConnection({\n  host : 'localhost',\n  ssl  : {\n    ca : fs.readFileSync(__dirname + '/mysql-ca.crt')\n  }\n});\n```\n\nYou can also connect to a MySQL server without properly providing the appropriate\nCA to trust. _You should not do this_.\n\n```js\nvar connection = mysql.createConnection({\n  host : 'localhost',\n  ssl  : {\n    // DO NOT DO THIS\n    // set up your ca correctly to trust the connection\n    rejectUnauthorized: false\n  }\n});\n```\n\n## Terminating connections\n\nThere are two ways to end a connection. Terminating a connection gracefully is\ndone by calling the `end()` method:\n\n```js\nconnection.end(function(err) {\n  // The connection is terminated now\n});\n```\n\nThis will make sure all previously enqueued queries are still before sending a\n`COM_QUIT` packet to the MySQL server. If a fatal error occurs before the\n`COM_QUIT` packet can be sent, an `err` argument will be provided to the\ncallback, but the connection will be terminated regardless of that.\n\nAn alternative way to end the connection is to call the `destroy()` method.\nThis will cause an immediate termination of the underlying socket.\nAdditionally `destroy()` guarantees that no more events or callbacks will be\ntriggered for the connection.\n\n```js\nconnection.destroy();\n```\n\nUnlike `end()` the `destroy()` method does not take a callback argument.\n\n## Pooling connections\n\nUse pool directly.\n```js\nvar mysql = require('mysql');\nvar pool  = mysql.createPool({\n  connectionLimit : 10,\n  host            : 'example.org',\n  user            : 'bob',\n  password        : 'secret'\n});\n\npool.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\nConnections can be pooled to ease sharing a single connection, or managing\nmultiple connections.\n\n```js\nvar mysql = require('mysql');\nvar pool  = mysql.createPool({\n  host     : 'example.org',\n  user     : 'bob',\n  password : 'secret'\n});\n\npool.getConnection(function(err, connection) {\n  // connected! (unless `err` is set)\n});\n```\n\nWhen you are done with a connection, just call `connection.release()` and the\nconnection will return to the pool, ready to be used again by someone else.\n\n```js\nvar mysql = require('mysql');\nvar pool  = mysql.createPool(...);\n\npool.getConnection(function(err, connection) {\n  // Use the connection\n  connection.query( 'SELECT something FROM sometable', function(err, rows) {\n    // And done with the connection.\n    connection.release();\n\n    // Don't use the connection here, it has been returned to the pool.\n  });\n});\n```\n\nIf you would like to close the connection and remove it from the pool, use\n`connection.destroy()` instead. The pool will create a new connection the next\ntime one is needed.\n\nConnections are lazily created by the pool. If you configure the pool to allow\nup to 100 connections, but only ever use 5 simultaneously, only 5 connections\nwill be made. Connections are also cycled round-robin style, with connections\nbeing taken from the top of the pool and returning to the bottom.\n\nWhen a previous connection is retrieved from the pool, a ping packet is sent\nto the server to check if the connection is still good.\n\n## Pool options\n\nPools accept all the same options as a connection. When creating a new\nconnection, the options are simply passed to the connection constructor. In\naddition to those options pools accept a few extras:\n\n* `acquireTimeout`: The milliseconds before a timeout occurs during the connection\n  acquisition. This is slightly different from `connectTimeout`, because acquiring\n  a pool connection does not always involve making a connection. (Default: 10 seconds)\n* `waitForConnections`: Determines the pool's action when no connections are\n  available and the limit has been reached. If `true`, the pool will queue the\n  connection request and call it when one becomes available. If `false`, the\n  pool will immediately call back with an error. (Default: `true`)\n* `connectionLimit`: The maximum number of connections to create at once.\n  (Default: `10`)\n* `queueLimit`: The maximum number of connection requests the pool will queue\n  before returning an error from `getConnection`. If set to `0`, there is no\n  limit to the number of queued connection requests. (Default: `0`)\n\n## Pool events\n\n### connection\n\nThe pool will emit a `connection` event when a new connection is made within the pool. \nIf you need to set session variables on the connection before it gets used, you can\nlisten to the `connection` event.\n\n```js\npool.on('connection', function (connection) {\n  connection.query('SET SESSION auto_increment_increment=1')\n});\n```\n\n### enqueue\n\nThe pool will emit an `enqueue` event when a callback has been queued to wait for\nan available connection.\n\n```js\npool.on('enqueue', function () {\n  console.log('Waiting for available connection slot');\n});\n```\n\n## Closing all the connections in a pool\n\nWhen you are done using the pool, you have to end all the connections or the\nNode.js event loop will stay active until the connections are closed by the\nMySQL server. This is typically done if the pool is used in a script or when\ntrying to gracefully shutdown a server. To end all the connections in the\npool, use the `end` method on the pool:\n\n```js\npool.end(function (err) {\n  // all connections in the pool have ended\n});\n```\n\nThe `end` method takes an _optional_ callback that you can use to know once\nall the connections have ended. The connections end _gracefully_, so all\npending queries will still complete and the time to end the pool will vary.\n\n**Once `pool.end()` has been called, `pool.getConnection` and other operations\ncan no longer be performed**\n\n## PoolCluster\n\nPoolCluster provides multiple hosts connection. (group & retry & selector)\n\n```js\n// create\nvar poolCluster = mysql.createPoolCluster();\n\npoolCluster.add(config); // anonymous group\npoolCluster.add('MASTER', masterConfig);\npoolCluster.add('SLAVE1', slave1Config);\npoolCluster.add('SLAVE2', slave2Config);\n\n// Target Group : ALL(anonymous, MASTER, SLAVE1-2), Selector : round-robin(default)\npoolCluster.getConnection(function (err, connection) {});\n\n// Target Group : MASTER, Selector : round-robin\npoolCluster.getConnection('MASTER', function (err, connection) {});\n\n// Target Group : SLAVE1-2, Selector : order\n// If can't connect to SLAVE1, return SLAVE2. (remove SLAVE1 in the cluster)\npoolCluster.on('remove', function (nodeId) {\n  console.log('REMOVED NODE : ' + nodeId); // nodeId = SLAVE1 \n});\n\npoolCluster.getConnection('SLAVE*', 'ORDER', function (err, connection) {});\n\n// of namespace : of(pattern, selector)\npoolCluster.of('*').getConnection(function (err, connection) {});\n\nvar pool = poolCluster.of('SLAVE*', 'RANDOM');\npool.getConnection(function (err, connection) {});\npool.getConnection(function (err, connection) {});\n\n// destroy\npoolCluster.end();\n```\n\n## PoolCluster Option\n* `canRetry`: If `true`, `PoolCluster` will attempt to reconnect when connection fails. (Default: `true`)\n* `removeNodeErrorCount`: If connection fails, node's `errorCount` increases. \n  When `errorCount` is greater than `removeNodeErrorCount`, remove a node in the `PoolCluster`. (Default: `5`)\n* `defaultSelector`: The default selector. (Default: `RR`)\n  * `RR`: Select one alternately. (Round-Robin)\n  * `RANDOM`: Select the node by random function.\n  * `ORDER`: Select the first node available unconditionally.\n\n```js\nvar clusterConfig = {\n  removeNodeErrorCount: 1, // Remove the node immediately when connection fails.\n  defaultSelector: 'ORDER'\n};\n\nvar poolCluster = mysql.createPoolCluster(clusterConfig);\n```\n\n## Switching users / altering connection state\n\nMySQL offers a changeUser command that allows you to alter the current user and\nother aspects of the connection without shutting down the underlying socket:\n\n```js\nconnection.changeUser({user : 'john'}, function(err) {\n  if (err) throw err;\n});\n```\n\nThe available options for this feature are:\n\n* `user`: The name of the new user (defaults to the previous one).\n* `password`: The password of the new user (defaults to the previous one).\n* `charset`: The new charset (defaults to the previous one).\n* `database`: The new database (defaults to the previous one).\n\nA sometimes useful side effect of this functionality is that this function also\nresets any connection state (variables, transactions, etc.).\n\nErrors encountered during this operation are treated as fatal connection errors\nby this module.\n\n## Server disconnects\n\nYou may lose the connection to a MySQL server due to network problems, the\nserver timing you out, the server being restarted, or crashing. All of these\nevents are considered fatal errors, and will have the `err.code =\n'PROTOCOL_CONNECTION_LOST'`.  See the [Error Handling](#error-handling) section\nfor more information.\n\nRe-connecting a connection is done by establishing a new connection. Once\nterminated, an existing connection object cannot be re-connected by design.\n\nWith Pool, disconnected connections will be removed from the pool freeing up\nspace for a new connection to be created on the next getConnection call.\n\n## Escaping query values\n\nIn order to avoid SQL Injection attacks, you should always escape any user\nprovided data before using it inside a SQL query. You can do so using the\n`connection.escape()` or `pool.escape()` methods:\n\n```js\nvar userId = 'some user provided value';\nvar sql    = 'SELECT * FROM users WHERE id = ' + connection.escape(userId);\nconnection.query(sql, function(err, results) {\n  // ...\n});\n```\n\nAlternatively, you can use `?` characters as placeholders for values you would\nlike to have escaped like this:\n\n```js\nconnection.query('SELECT * FROM users WHERE id = ?', [userId], function(err, results) {\n  // ...\n});\n```\n\nThis looks similar to prepared statements in MySQL, however it really just uses\nthe same `connection.escape()` method internally.\n\n**Caution** This also differs from prepared statements in that all `?` are\nreplaced, even those contained in comments and strings.\n\nDifferent value types are escaped differently, here is how:\n\n* Numbers are left untouched\n* Booleans are converted to `true` / `false` strings\n* Date objects are converted to `'YYYY-mm-dd HH:ii:ss'` strings\n* Buffers are converted to hex strings, e.g. `X'0fa5'`\n* Strings are safely escaped\n* Arrays are turned into list, e.g. `['a', 'b']` turns into `'a', 'b'`\n* Nested arrays are turned into grouped lists (for bulk inserts), e.g. `[['a',\n  'b'], ['c', 'd']]` turns into `('a', 'b'), ('c', 'd')`\n* Objects are turned into `key = 'val'` pairs. Nested objects are cast to\n  strings.\n* `undefined` / `null` are converted to `NULL`\n* `NaN` / `Infinity` are left as-is. MySQL does not support these, and trying\n  to insert them as values will trigger MySQL errors until they implement\n  support.\n\nIf you paid attention, you may have noticed that this escaping allows you\nto do neat things like this:\n\n```js\nvar post  = {id: 1, title: 'Hello MySQL'};\nvar query = connection.query('INSERT INTO posts SET ?', post, function(err, result) {\n  // Neat!\n});\nconsole.log(query.sql); // INSERT INTO posts SET `id` = 1, `title` = 'Hello MySQL'\n\n```\n\nIf you feel the need to escape queries by yourself, you can also use the escaping\nfunction directly:\n\n```js\nvar query = \"SELECT * FROM posts WHERE title=\" + mysql.escape(\"Hello MySQL\");\n\nconsole.log(query); // SELECT * FROM posts WHERE title='Hello MySQL'\n```\n\n## Escaping query identifiers\n\nIf you can't trust an SQL identifier (database / table / column name) because it is\nprovided by a user, you should escape it with `mysql.escapeId(identifier)`,\n`connection.escapeId(identifier)` or `pool.escapeId(identifier)` like this:\n\n```js\nvar sorter = 'date';\nvar sql    = 'SELECT * FROM posts ORDER BY ' + connection.escapeId(sorter);\nconnection.query(sql, function(err, results) {\n  // ...\n});\n```\n\nIt also supports adding qualified identifiers. It will escape both parts.\n\n```js\nvar sorter = 'date';\nvar sql    = 'SELECT * FROM posts ORDER BY ' + connection.escapeId('posts.' + sorter);\nconnection.query(sql, function(err, results) {\n  // ...\n});\n```\n\nAlternatively, you can use `??` characters as placeholders for identifiers you would\nlike to have escaped like this:\n\n```js\nvar userId = 1;\nvar columns = ['username', 'email'];\nvar query = connection.query('SELECT ?? FROM ?? WHERE id = ?', [columns, 'users', userId], function(err, results) {\n  // ...\n});\n\nconsole.log(query.sql); // SELECT `username`, `email` FROM `users` WHERE id = 1\n```\n**Please note that this last character sequence is experimental and syntax might change**\n\nWhen you pass an Object to `.escape()` or `.query()`, `.escapeId()` is used to avoid SQL injection in object keys.\n\n### Preparing Queries\n\nYou can use mysql.format to prepare a query with multiple insertion points, utilizing the proper escaping for ids and values. A simple example of this follows:\n\n```js\nvar sql = \"SELECT * FROM ?? WHERE ?? = ?\";\nvar inserts = ['users', 'id', userId];\nsql = mysql.format(sql, inserts);\n```\n\nFollowing this you then have a valid, escaped query that you can then send to the database safely. This is useful if you are looking to prepare the query before actually sending it to the database. As mysql.format is exposed from SqlString.format you also have the option (but are not required) to pass in stringifyObject and timezone, allowing you provide a custom means of turning objects into strings, as well as a location-specific/timezone-aware Date.\n\n### Custom format\n\nIf you prefer to have another type of query escape format, there's a connection configuration option you can use to define a custom format function. You can access the connection object if you want to use the built-in `.escape()` or any other connection function.\n\nHere's an example of how to implement another format:\n\n```js\nconnection.config.queryFormat = function (query, values) {\n  if (!values) return query;\n  return query.replace(/\\:(\\w+)/g, function (txt, key) {\n    if (values.hasOwnProperty(key)) {\n      return this.escape(values[key]);\n    }\n    return txt;\n  }.bind(this));\n};\n\nconnection.query(\"UPDATE posts SET title = :title\", { title: \"Hello MySQL\" });\n```\n\n## Getting the id of an inserted row\n\nIf you are inserting a row into a table with an auto increment primary key, you\ncan retrieve the insert id like this:\n\n```js\nconnection.query('INSERT INTO posts SET ?', {title: 'test'}, function(err, result) {\n  if (err) throw err;\n\n  console.log(result.insertId);\n});\n```\n\nWhen dealing with big numbers (above JavaScript Number precision limit), you should\nconsider enabling `supportBigNumbers` option to be able to read the insert id as a\nstring, otherwise it will throw.\n\nThis option is also required when fetching big numbers from the database, otherwise\nyou will get values rounded to hundreds or thousands due to the precision limit.\n\n## Getting the number of affected rows.\n\nYou can get the number of affected rows from an insert, update or delete statement.\n\n```js\nconnection.query('DELETE FROM posts WHERE title = \"wrong\"', function (err, result) {\n  if (err) throw err;\n\n  console.log('deleted ' + result.affectedRows + ' rows');\n})\n```\n\n## Getting the number of changed rows.\n\nYou can get the number of changed rows from an update statement.\n\n\"changedRows\" differs from \"affectedRows\" in that it does not count updated rows\nwhose values were not changed.\n\n```js\nconnection.query('UPDATE posts SET ...', function (err, result) {\n  if (err) throw err;\n\n  console.log('changed ' + result.changedRows + ' rows');\n})\n```\n\n## Getting the connection ID\n\nYou can get the MySQL connection ID (\"thread ID\") of a given connection using the `threadId`\nproperty.\n\n```js\nconnection.connect(function(err) {\n  if (err) throw err;\n  console.log('connected as id ' + connection.threadId);\n});\n```\n\n## Executing queries in parallel\n\nThe MySQL protocol is sequential, this means that you need multiple connections\nto execute queries in parallel. You can use a Pool to manage connections, one\nsimple approach is to create one connection per incoming http request.\n\n## Streaming query rows\n\nSometimes you may want to select large quantities of rows and process each of\nthem as they are received. This can be done like this:\n\n```js\nvar query = connection.query('SELECT * FROM posts');\nquery\n  .on('error', function(err) {\n    // Handle error, an 'end' event will be emitted after this as well\n  })\n  .on('fields', function(fields) {\n    // the field packets for the rows to follow\n  })\n  .on('result', function(row) {\n    // Pausing the connnection is useful if your processing involves I/O\n    connection.pause();\n\n    processRow(row, function() {\n      connection.resume();\n    });\n  })\n  .on('end', function() {\n    // all rows have been received\n  });\n```\n\nPlease note a few things about the example above:\n\n* Usually you will want to receive a certain amount of rows before starting to\n  throttle the connection using `pause()`. This number will depend on the\n  amount and size of your rows.\n* `pause()` / `resume()` operate on the underlying socket and parser. You are\n  guaranteed that no more `'result'` events will fire after calling `pause()`.\n* You MUST NOT provide a callback to the `query()` method when streaming rows.\n* The `'result'` event will fire for both rows as well as OK packets\n  confirming the success of a INSERT/UPDATE query.\n\nAdditionally you may be interested to know that it is currently not possible to\nstream individual row columns, they will always be buffered up entirely. If you\nhave a good use case for streaming large fields to and from MySQL, I'd love to\nget your thoughts and contributions on this.\n\n### Piping results with [Streams2](http://blog.nodejs.org/2012/12/20/streams2/)\n\nThe query object provides a convenience method `.stream([options])` that wraps\nquery events into a [Readable](http://nodejs.org/api/stream.html#stream_class_stream_readable)\nStreams2 object.  This stream can easily be piped downstream and provides\nautomatic pause/resume, based on downstream congestion and the optional\n`highWaterMark`. The `objectMode` parameter of the stream is set to `true` by\ndefault.\n\nFor example, piping query results into another stream (with a max buffer of 5\nobjects) is simply:\n\n```js\nconnection.query('SELECT * FROM posts')\n  .stream({highWaterMark: 5})\n  .pipe(...);\n```\n\n## Multiple statement queries\n\nSupport for multiple statements is disabled for security reasons (it allows for\nSQL injection attacks if values are not properly escaped). To use this feature\nyou have to enable it for your connection:\n\n```js\nvar connection = mysql.createConnection({multipleStatements: true});\n```\n\nOnce enabled, you can execute multiple statement queries like any other query:\n\n```js\nconnection.query('SELECT 1; SELECT 2', function(err, results) {\n  if (err) throw err;\n\n  // `results` is an array with one element for every statement in the query:\n  console.log(results[0]); // [{1: 1}]\n  console.log(results[1]); // [{2: 2}]\n});\n```\n\nAdditionally you can also stream the results of multiple statement queries:\n\n```js\nvar query = connection.query('SELECT 1; SELECT 2');\n\nquery\n  .on('fields', function(fields, index) {\n    // the fields for the result rows that follow\n  })\n  .on('result', function(row, index) {\n    // index refers to the statement this result belongs to (starts at 0)\n  });\n```\n\nIf one of the statements in your query causes an error, the resulting Error\nobject contains a `err.index` property which tells you which statement caused\nit. MySQL will also stop executing any remaining statements when an error\noccurs.\n\nPlease note that the interface for streaming multiple statement queries is\nexperimental and I am looking forward to feedback on it.\n\n## Stored procedures\n\nYou can call stored procedures from your queries as with any other mysql driver.\nIf the stored procedure produces several result sets, they are exposed to you\nthe same way as the results for multiple statement queries.\n\n## Joins with overlapping column names\n\nWhen executing joins, you are likely to get result sets with overlapping column\nnames.\n\nBy default, node-mysql will overwrite colliding column names in the\norder the columns are received from MySQL, causing some of the received values\nto be unavailable.\n\nHowever, you can also specify that you want your columns to be nested below\nthe table name like this:\n\n```js\nvar options = {sql: '...', nestTables: true};\nconnection.query(options, function(err, results) {\n  /* results will be an array like this now:\n  [{\n    table1: {\n      fieldA: '...',\n      fieldB: '...',\n    },\n    table2: {\n      fieldA: '...',\n      fieldB: '...',\n    },\n  }, ...]\n  */\n});\n```\n\nOr use a string separator to have your results merged.\n\n```js\nvar options = {sql: '...', nestTables: '_'};\nconnection.query(options, function(err, results) {\n  /* results will be an array like this now:\n  [{\n    table1_fieldA: '...',\n    table1_fieldB: '...',\n    table2_fieldA: '...',\n    table2_fieldB: '...',\n  }, ...]\n  */\n});\n```\n\n## Transactions\n\nSimple transaction support is available at the connection level:\n\n```js\nconnection.beginTransaction(function(err) {\n  if (err) { throw err; }\n  connection.query('INSERT INTO posts SET title=?', title, function(err, result) {\n    if (err) { \n      connection.rollback(function() {\n        throw err;\n      });\n    }\n\n\tvar log = 'Post ' + result.insertId + ' added';\n\n\tconnection.query('INSERT INTO log SET data=?', log, function(err, result) {\n\t  if (err) { \n        connection.rollback(function() {\n          throw err;\n        });\n      }  \n\t  connection.commit(function(err) {\n\t    if (err) { \n          connection.rollback(function() {\n            throw err;\n          });\n        }\n\t    console.log('success!');\n\t  });\n    });\n  });\n});\n```\nPlease note that beginTransaction(), commit() and rollback() are simply convenience\nfunctions that execute the START TRANSACTION, COMMIT, and ROLLBACK commands respectively.\nIt is important to understand that many commands in MySQL can cause an implicit commit,\nas described [in the MySQL documentation](http://dev.mysql.com/doc/refman/5.5/en/implicit-commit.html)\n\n## Timeouts\n\nEvery operation takes an optional inactivity timeout option. This allows you to\nspecify appropriate timeouts for operations. It is important to note that these\ntimeouts are not part of the MySQL protocol, and rather timeout operations through\nthe client. This means that when a timeout is reached, the connection it occurred\non will be destroyed and no further operations can be performed.\n\n```js\n// Kill query after 60s\nconnection.query({sql: 'SELECT COUNT(*) AS count FROM big_table', timeout: 60000}, function (err, rows) {\n  if (err && err.code === 'PROTOCOL_SEQUENCE_TIMEOUT') {\n    throw new Error('too long to count table rows!');\n  }\n\n  if (err) {\n    throw err;\n  }\n\n  console.log(rows[0].count + ' rows');\n});\n```\n\n## Error handling\n\nThis module comes with a consistent approach to error handling that you should\nreview carefully in order to write solid applications.\n\nAll errors created by this module are instances of the JavaScript [Error][]\nobject. Additionally they come with two properties:\n\n* `err.code`: Either a [MySQL server error][] (e.g.\n  `'ER_ACCESS_DENIED_ERROR'`), a node.js error (e.g. `'ECONNREFUSED'`) or an\n  internal error (e.g.  `'PROTOCOL_CONNECTION_LOST'`).\n* `err.fatal`: Boolean, indicating if this error is terminal to the connection\n  object.\n\n[Error]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n[MySQL server error]: http://dev.mysql.com/doc/refman/5.5/en/error-messages-server.html\n\nFatal errors are propagated to *all* pending callbacks. In the example below, a\nfatal error is triggered by trying to connect to an invalid port. Therefore the\nerror object is propagated to both pending callbacks:\n\n```js\nvar connection = require('mysql').createConnection({\n  port: 84943, // WRONG PORT\n});\n\nconnection.connect(function(err) {\n  console.log(err.code); // 'ECONNREFUSED'\n  console.log(err.fatal); // true\n});\n\nconnection.query('SELECT 1', function(err) {\n  console.log(err.code); // 'ECONNREFUSED'\n  console.log(err.fatal); // true\n});\n```\n\nNormal errors however are only delegated to the callback they belong to.  So in\nthe example below, only the first callback receives an error, the second query\nworks as expected:\n\n```js\nconnection.query('USE name_of_db_that_does_not_exist', function(err, rows) {\n  console.log(err.code); // 'ER_BAD_DB_ERROR'\n});\n\nconnection.query('SELECT 1', function(err, rows) {\n  console.log(err); // null\n  console.log(rows.length); // 1\n});\n```\n\nLast but not least: If a fatal errors occurs and there are no pending\ncallbacks, or a normal error occurs which has no callback belonging to it, the\nerror is emitted as an `'error'` event on the connection object. This is\ndemonstrated in the example below:\n\n```js\nconnection.on('error', function(err) {\n  console.log(err.code); // 'ER_BAD_DB_ERROR'\n});\n\nconnection.query('USE name_of_db_that_does_not_exist');\n```\n\nNote: `'error'` are special in node. If they occur without an attached\nlistener, a stack trace is printed and your process is killed.\n\n**tl;dr:** This module does not want you to deal with silent failures. You\nshould always provide callbacks to your method calls. If you want to ignore\nthis advice and suppress unhandled errors, you can do this:\n\n```js\n// I am Chuck Norris:\nconnection.on('error', function() {});\n```\n\n## Exception Safety\n\nThis module is exception safe. That means you can continue to use it, even if\none of your callback functions throws an error which you're catching using\n'uncaughtException' or a domain.\n\n## Type casting\n\nFor your convenience, this driver will cast mysql types into native JavaScript\ntypes by default. The following mappings exist:\n\n### Number\n\n* TINYINT\n* SMALLINT\n* INT\n* MEDIUMINT\n* YEAR\n* FLOAT\n* DOUBLE\n\n### Date\n\n* TIMESTAMP\n* DATE\n* DATETIME\n\n### Buffer\n\n* TINYBLOB\n* MEDIUMBLOB\n* LONGBLOB\n* BLOB\n* BINARY\n* VARBINARY\n* BIT (last byte will be filled with 0 bits as necessary)\n\n### String\n\n* CHAR\n* VARCHAR\n* TINYTEXT\n* MEDIUMTEXT\n* LONGTEXT\n* TEXT\n* ENUM\n* SET\n* DECIMAL (may exceed float precision)\n* BIGINT (may exceed float precision)\n* TIME (could be mapped to Date, but what date would be set?)\n* GEOMETRY (never used those, get in touch if you do)\n\nIt is not recommended (and may go away / change in the future) to disable type\ncasting, but you can currently do so on either the connection:\n\n```js\nvar connection = require('mysql').createConnection({typeCast: false});\n```\n\nOr on the query level:\n\n```js\nvar options = {sql: '...', typeCast: false};\nvar query = connection.query(options, function(err, results) {\n\n});\n```\n\nYou can also pass a function and handle type casting yourself. You're given some\ncolumn information like database, table and name and also type and length. If you\njust want to apply a custom type casting to a specific type you can do it and then\nfallback to the default. Here's an example of converting `TINYINT(1)` to boolean:\n\n```js\nconnection.query({\n  sql: '...',\n  typeCast: function (field, next) {\n    if (field.type == 'TINY' && field.length == 1) {\n      return (field.string() == '1'); // 1 = true, 0 = false\n    }\n    return next();\n  }\n});\n```\n__WARNING: YOU MUST INVOKE the parser using one of these three field functions in your custom typeCast callback. They can only be called once.( see #539 for discussion)__\n\n```\nfield.string()\nfield.buffer()\nfield.geometry()\n```\nare aliases for\n```\nparser.parseLengthCodedString()\nparser.parseLengthCodedBuffer()\nparser.parseGeometryValue()\n```\n__You can find which field function you need to use by looking at: [RowDataPacket.prototype._typeCast](https://github.com/felixge/node-mysql/blob/master/lib/protocol/packets/RowDataPacket.js#L41)__\n\n\n## Connection Flags\n\nIf, for any reason, you would like to change the default connection flags, you\ncan use the connection option `flags`. Pass a string with a comma separated list\nof items to add to the default flags. If you don't want a default flag to be used\nprepend the flag with a minus sign. To add a flag that is not in the default list,\njust write the flag name, or prefix it with a plus (case insensitive).\n\n**Please note that some available flags that are not not supported (e.g.: Compression),\nare still not allowed to be specified.**\n\n### Example\n\nThe next example blacklists FOUND_ROWS flag from default connection flags.\n\n```js\nvar connection = mysql.createConnection(\"mysql://localhost/test?flags=-FOUND_ROWS\");\n```\n\n### Default Flags\n\nThe following flags are sent by default on a new connection:\n\n- `CONNECT_WITH_DB` - Ability to specify the database on connection.\n- `FOUND_ROWS` - Send the found rows instead of the affected rows as `affectedRows`.\n- `IGNORE_SIGPIPE` - Old; no effect.\n- `IGNORE_SPACE` - Let the parser ignore spaces before the `(` in queries.\n- `LOCAL_FILES` - Can use `LOAD DATA LOCAL`.\n- `LONG_FLAG`\n- `LONG_PASSWORD` - Use the improved version of Old Password Authentication.\n- `MULTI_RESULTS` - Can handle multiple resultsets for COM_QUERY.\n- `ODBC` Old; no effect.\n- `PROTOCOL_41` - Uses the 4.1 protocol.\n- `PS_MULTI_RESULTS` - Can handle multiple resultsets for COM_STMT_EXECUTE.\n- `RESERVED` - Old flag for the 4.1 protocol.\n- `SECURE_CONNECTION` - Support native 4.1 authentication.\n- `TRANSACTIONS` - Asks for the transaction status flags.\n\nIn addition, the following flag will be sent if the option `multipleStatements`\nis set to `true`:\n\n- `MULTI_STATEMENTS` - The client may send multiple statement per query or\n  statement prepare.\n\n### Other Available Flags\n\nThere are other flags available. They may or may not function, but are still\navailable to specify.\n\n- COMPRESS\n- INTERACTIVE\n- NO_SCHEMA\n- PLUGIN_AUTH\n- REMEMBER_OPTIONS\n- SSL\n- SSL_VERIFY_SERVER_CERT\n\n## Debugging and reporting problems\n\nIf you are running into problems, one thing that may help is enabling the\n`debug` mode for the connection:\n\n```js\nvar connection = mysql.createConnection({debug: true});\n```\n\nThis will print all incoming and outgoing packets on stdout. You can also restrict debugging to\npacket types by passing an array of types to debug:\n\n```js\nvar connection = mysql.createConnection({debug: ['ComQueryPacket', 'RowDataPacket']});\n```\n\nto restrict debugging to the query and data packets.\n\nIf that does not help, feel free to open a GitHub issue. A good GitHub issue\nwill have:\n\n* The minimal amount of code required to reproduce the problem (if possible)\n* As much debugging output and information about your environment (mysql\n  version, node version, os, etc.) as you can gather.\n\n## Running tests\n\nThe test suite is split into two parts: unit tests and integration tests.\nThe unit tests run on any machine while the integration tests require a\nMySQL server instance to be setup.\n\n### Running unit tests\n\n```sh\n$ FILTER=unit npm test\n```\n\n### Running integration tests\n\nSet the environment variables `MYSQL_DATABASE`, `MYSQL_HOST`, `MYSQL_PORT`,\n`MYSQL_USER` and `MYSQL_PASSWORD`. Then run `npm test`.\n\nFor example, if you have an installation of mysql running on localhost:3306\nand no password set for the `root` user, run:\n\n```sh\n$ mysql -u root -e \"CREATE DATABASE IF NOT EXISTS node_mysql_test\"\n$ MYSQL_HOST=localhost MYSQL_PORT=3306 MYSQL_DATABASE=node_mysql_test MYSQL_USER=root MYSQL_PASSWORD= FILTER=integration npm test\n```\n\n## Todo\n\n* Prepared statements\n* Support for encodings other than UTF-8 / ASCII\n\n[npm-image]: https://img.shields.io/npm/v/mysql.svg?style=flat\n[npm-url]: https://npmjs.org/package/mysql\n[node-version-image]: https://img.shields.io/badge/node.js-%3E%3D_0.6-brightgreen.svg?style=flat\n[node-version-url]: http://nodejs.org/download/\n[travis-image]: https://img.shields.io/travis/felixge/node-mysql.svg?style=flat\n[travis-url]: https://travis-ci.org/felixge/node-mysql\n[coveralls-image]: https://img.shields.io/coveralls/felixge/node-mysql.svg?style=flat\n[coveralls-url]: https://coveralls.io/r/felixge/node-mysql?branch=master\n[downloads-image]: https://img.shields.io/npm/dm/mysql.svg?style=flat\n[downloads-url]: https://npmjs.org/package/mysql\n",
   51    "readmeFilename": "Readme.md",
   52    "bugs": {

/Users/student/Desktop/2014-09-databases/node_modules/mysql/Readme.md:
  678  ```
  679
  680: ## Executing queries in parallel
  681
  682  The MySQL protocol is sequential, this means that you need multiple connections
  ...
  783  If one of the statements in your query causes an error, the resulting Error
  784  object contains a `err.index` property which tells you which statement caused
  785: it. MySQL will also stop executing any remaining statements when an error
  786  occurs.
  787
  ...
  797  ## Joins with overlapping column names
  798
  799: When executing joins, you are likely to get result sets with overlapping column
  800  names.
  801

/Users/student/Desktop/2014-09-databases/node_modules/mysql/lib/protocol/constants/errors.js:
  327  exports.ER_CONNECT_TO_MASTER                                                = 1218;
  328  exports.ER_QUERY_ON_MASTER                                                  = 1219;
  329: exports.ER_ERROR_WHEN_EXECUTING_COMMAND                                     = 1220;
  330  exports.ER_WRONG_USAGE                                                      = 1221;
  331  exports.ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT                                = 1222;
  ...
 1314  exports[1218] = 'ER_CONNECT_TO_MASTER';
 1315  exports[1219] = 'ER_QUERY_ON_MASTER';
 1316: exports[1220] = 'ER_ERROR_WHEN_EXECUTING_COMMAND';
 1317  exports[1221] = 'ER_WRONG_USAGE';
 1318  exports[1222] = 'ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT';

/Users/student/Desktop/2014-09-databases/node_modules/request/node_modules/form-data/node_modules/async/package.json:
   36      "test": "nodeunit test/test-async.js"
   37    },
   38:   "readme": "# Async.js\n\n[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\n\n\nAsync is a utility module which provides straight-forward, powerful functions\nfor working with asynchronous JavaScript. Although originally designed for\nuse with [Node.js](http://nodejs.org), it can also be used directly in the\nbrowser. Also supports [component](https://github.com/component/component).\n\nAsync provides around 20 functions that include the usual 'functional'\nsuspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\nfor asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\nfunctions assume you follow the Node.js convention of providing a single\ncallback as the last argument of your `async` function.\n\n\n## Quick Examples\n\n```javascript\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n\nasync.parallel([\n    function(){ ... },\n    function(){ ... }\n], callback);\n\nasync.series([\n    function(){ ... },\n    function(){ ... }\n]);\n```\n\nThere are many more functions available so take a look at the docs below for a\nfull list. This module aims to be comprehensive, so if you feel anything is\nmissing please create a GitHub issue for it.\n\n## Common Pitfalls\n\n### Binding a context to an iterator\n\nThis section is really about `bind`, not about `async`. If you are wondering how to\nmake `async` execute your iterators in a given context, or are confused as to why\na method of another library isn't working as an iterator, study this example:\n\n```js\n// Here is a simple object with an (unnecessarily roundabout) squaring method\nvar AsyncSquaringLibrary = {\n  squareExponent: 2,\n  square: function(number, callback){ \n    var result = Math.pow(number, this.squareExponent);\n    setTimeout(function(){\n      callback(null, result);\n    }, 200);\n  }\n};\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\n  // result is [NaN, NaN, NaN]\n  // This fails because the `this.squareExponent` expression in the square\n  // function is not evaluated in the context of AsyncSquaringLibrary, and is\n  // therefore undefined.\n});\n\nasync.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\n  // result is [1, 4, 9]\n  // With the help of bind we can attach a context to the iterator before\n  // passing it to async. Now the square function will be executed in its \n  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\n  // will be as expected.\n});\n```\n\n## Download\n\nThe source is available for download from\n[GitHub](http://github.com/caolan/async).\nAlternatively, you can install using Node Package Manager (`npm`):\n\n    npm install async\n\n__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\n\n## In the Browser\n\nSo far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \n\nUsage:\n\n```html\n<script type=\"text/javascript\" src=\"async.js\"></script>\n<script type=\"text/javascript\">\n\n    async.map(data, asyncProcess, function(err, results){\n        alert(results);\n    });\n\n</script>\n```\n\n## Documentation\n\n### Collections\n\n* [`each`](#each)\n* [`eachSeries`](#eachSeries)\n* [`eachLimit`](#eachLimit)\n* [`map`](#map)\n* [`mapSeries`](#mapSeries)\n* [`mapLimit`](#mapLimit)\n* [`filter`](#filter)\n* [`filterSeries`](#filterSeries)\n* [`reject`](#reject)\n* [`rejectSeries`](#rejectSeries)\n* [`reduce`](#reduce)\n* [`reduceRight`](#reduceRight)\n* [`detect`](#detect)\n* [`detectSeries`](#detectSeries)\n* [`sortBy`](#sortBy)\n* [`some`](#some)\n* [`every`](#every)\n* [`concat`](#concat)\n* [`concatSeries`](#concatSeries)\n\n### Control Flow\n\n* [`series`](#seriestasks-callback)\n* [`parallel`](#parallel)\n* [`parallelLimit`](#parallellimittasks-limit-callback)\n* [`whilst`](#whilst)\n* [`doWhilst`](#doWhilst)\n* [`until`](#until)\n* [`doUntil`](#doUntil)\n* [`forever`](#forever)\n* [`waterfall`](#waterfall)\n* [`compose`](#compose)\n* [`seq`](#seq)\n* [`applyEach`](#applyEach)\n* [`applyEachSeries`](#applyEachSeries)\n* [`queue`](#queue)\n* [`priorityQueue`](#priorityQueue)\n* [`cargo`](#cargo)\n* [`auto`](#auto)\n* [`retry`](#retry)\n* [`iterator`](#iterator)\n* [`apply`](#apply)\n* [`nextTick`](#nextTick)\n* [`times`](#times)\n* [`timesSeries`](#timesSeries)\n\n### Utils\n\n* [`memoize`](#memoize)\n* [`unmemoize`](#unmemoize)\n* [`log`](#log)\n* [`dir`](#dir)\n* [`noConflict`](#noConflict)\n\n\n## Collections\n\n<a name=\"forEach\" />\n<a name=\"each\" />\n### each(arr, iterator, callback)\n\nApplies the function `iterator` to each item in `arr`, in parallel.\nThe `iterator` is called with an item from the list, and a callback for when it\nhas finished. If the `iterator` passes an error to its `callback`, the main\n`callback` (for the `each` function) is immediately called with the error.\n\nNote, that since this function applies `iterator` to each item in parallel,\nthere is no guarantee that the iterator functions will complete in order.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err)` which must be called once it has \n  completed. If no error has occured, the `callback` should be run without \n  arguments or with an explicit `null` argument.\n* `callback(err)` - A callback which is called when all `iterator` functions\n  have finished, or an error occurs.\n\n__Examples__\n\n\n```js\n// assuming openFiles is an array of file names and saveFile is a function\n// to save the modified contents of that file:\n\nasync.each(openFiles, saveFile, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n```js\n// assuming openFiles is an array of file names \n\nasync.each(openFiles, function( file, callback) {\n  \n  // Perform operation on file here.\n  console.log('Processing file ' + file);\n  \n  if( file.length > 32 ) {\n    console.log('This file name is too long');\n    callback('File name too long');\n  } else {\n    // Do work to process file here\n    console.log('File processed');\n    callback();\n  }\n}, function(err){\n    // if any of the file processing produced an error, err would equal that error\n    if( err ) {\n      // One of the iterations produced an error.\n      // All processing will now stop.\n      console.log('A file failed to process');\n    } else {\n      console.log('All files have been processed successfully');\n    }\n});\n```\n\n---------------------------------------\n\n<a name=\"forEachSeries\" />\n<a name=\"eachSeries\" />\n### eachSeries(arr, iterator, callback)\n\nThe same as [`each`](#each), only `iterator` is applied to each item in `arr` in\nseries. The next `iterator` is only called once the current one has completed. \nThis means the `iterator` functions will complete in order.\n\n\n---------------------------------------\n\n<a name=\"forEachLimit\" />\n<a name=\"eachLimit\" />\n### eachLimit(arr, limit, iterator, callback)\n\nThe same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \nrunning at any time.\n\nNote that the items in `arr` are not processed in batches, so there is no guarantee that \nthe first `limit` `iterator` functions will complete before any others are started.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `limit` - The maximum number of `iterator`s to run at any time.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err)` which must be called once it has \n  completed. If no error has occured, the callback should be run without \n  arguments or with an explicit `null` argument.\n* `callback(err)` - A callback which is called when all `iterator` functions\n  have finished, or an error occurs.\n\n__Example__\n\n```js\n// Assume documents is an array of JSON objects and requestApi is a\n// function that interacts with a rate-limited REST api.\n\nasync.eachLimit(documents, 20, requestApi, function(err){\n    // if any of the saves produced an error, err would equal that error\n});\n```\n\n---------------------------------------\n\n<a name=\"map\" />\n### map(arr, iterator, callback)\n\nProduces a new array of values by mapping each value in `arr` through\nthe `iterator` function. The `iterator` is called with an item from `arr` and a\ncallback for when it has finished processing. Each of these callback takes 2 arguments: \nan `error`, and the transformed item from `arr`. If `iterator` passes an error to this \ncallback, the main `callback` (for the `map` function) is immediately called with the error.\n\nNote, that since this function applies the `iterator` to each item in parallel,\nthere is no guarantee that the `iterator` functions will complete in order. \nHowever, the results array will be in the same order as the original `arr`.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err, transformed)` which must be called once \n  it has completed with an error (which can be `null`) and a transformed item.\n* `callback(err, results)` - A callback which is called when all `iterator`\n  functions have finished, or an error occurs. Results is an array of the\n  transformed items from the `arr`.\n\n__Example__\n\n```js\nasync.map(['file1','file2','file3'], fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"mapSeries\" />\n### mapSeries(arr, iterator, callback)\n\nThe same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\nseries. The next `iterator` is only called once the current one has completed. \nThe results array will be in the same order as the original.\n\n\n---------------------------------------\n\n<a name=\"mapLimit\" />\n### mapLimit(arr, limit, iterator, callback)\n\nThe same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \nrunning at any time.\n\nNote that the items are not processed in batches, so there is no guarantee that \nthe first `limit` `iterator` functions will complete before any others are started.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `limit` - The maximum number of `iterator`s to run at any time.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err, transformed)` which must be called once \n  it has completed with an error (which can be `null`) and a transformed item.\n* `callback(err, results)` - A callback which is called when all `iterator`\n  calls have finished, or an error occurs. The result is an array of the\n  transformed items from the original `arr`.\n\n__Example__\n\n```js\nasync.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\n    // results is now an array of stats for each file\n});\n```\n\n---------------------------------------\n\n<a name=\"select\" />\n<a name=\"filter\" />\n### filter(arr, iterator, callback)\n\n__Alias:__ `select`\n\nReturns a new array of all the values in `arr` which pass an async truth test.\n_The callback for each `iterator` call only accepts a single argument of `true` or\n`false`; it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like `fs.exists`. This operation is\nperformed in parallel, but the results array will be in the same order as the\noriginal.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n  The `iterator` is passed a `callback(truthValue)`, which must be called with a \n  boolean argument once it has completed.\n* `callback(results)` - A callback which is called after all the `iterator`\n  functions have finished.\n\n__Example__\n\n```js\nasync.filter(['file1','file2','file3'], fs.exists, function(results){\n    // results now equals an array of the existing files\n});\n```\n\n---------------------------------------\n\n<a name=\"selectSeries\" />\n<a name=\"filterSeries\" />\n### filterSeries(arr, iterator, callback)\n\n__Alias:__ `selectSeries`\n\nThe same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\nseries. The next `iterator` is only called once the current one has completed. \nThe results array will be in the same order as the original.\n\n---------------------------------------\n\n<a name=\"reject\" />\n### reject(arr, iterator, callback)\n\nThe opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\n\n---------------------------------------\n\n<a name=\"rejectSeries\" />\n### rejectSeries(arr, iterator, callback)\n\nThe same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\nin series.\n\n\n---------------------------------------\n\n<a name=\"reduce\" />\n### reduce(arr, memo, iterator, callback)\n\n__Aliases:__ `inject`, `foldl`\n\nReduces `arr` into a single value using an async `iterator` to return\neach successive step. `memo` is the initial state of the reduction. \nThis function only operates in series. \n\nFor performance reasons, it may make sense to split a call to this function into \na parallel map, and then use the normal `Array.prototype.reduce` on the results. \nThis function is for situations where each step in the reduction needs to be async; \nif you can get the data before reducing it, then it's probably a good idea to do so.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `memo` - The initial state of the reduction.\n* `iterator(memo, item, callback)` - A function applied to each item in the\n  array to produce the next step in the reduction. The `iterator` is passed a\n  `callback(err, reduction)` which accepts an optional error as its first \n  argument, and the state of the reduction as the second. If an error is \n  passed to the callback, the reduction is stopped and the main `callback` is \n  immediately called with the error.\n* `callback(err, result)` - A callback which is called after all the `iterator`\n  functions have finished. Result is the reduced value.\n\n__Example__\n\n```js\nasync.reduce([1,2,3], 0, function(memo, item, callback){\n    // pointless async:\n    process.nextTick(function(){\n        callback(null, memo + item)\n    });\n}, function(err, result){\n    // result is now equal to the last value of memo, which is 6\n});\n```\n\n---------------------------------------\n\n<a name=\"reduceRight\" />\n### reduceRight(arr, memo, iterator, callback)\n\n__Alias:__ `foldr`\n\nSame as [`reduce`](#reduce), only operates on `arr` in reverse order.\n\n\n---------------------------------------\n\n<a name=\"detect\" />\n### detect(arr, iterator, callback)\n\nReturns the first value in `arr` that passes an async truth test. The\n`iterator` is applied in parallel, meaning the first iterator to return `true` will\nfire the detect `callback` with that result. That means the result might not be\nthe first item in the original `arr` (in terms of order) that passes the test.\n\nIf order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n  The iterator is passed a `callback(truthValue)` which must be called with a \n  boolean argument once it has completed.\n* `callback(result)` - A callback which is called as soon as any iterator returns\n  `true`, or after all the `iterator` functions have finished. Result will be\n  the first item in the array that passes the truth test (iterator) or the\n  value `undefined` if none passed.\n\n__Example__\n\n```js\nasync.detect(['file1','file2','file3'], fs.exists, function(result){\n    // result now equals the first file in the list that exists\n});\n```\n\n---------------------------------------\n\n<a name=\"detectSeries\" />\n### detectSeries(arr, iterator, callback)\n\nThe same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\nin series. This means the result is always the first in the original `arr` (in\nterms of array order) that passes the truth test.\n\n\n---------------------------------------\n\n<a name=\"sortBy\" />\n### sortBy(arr, iterator, callback)\n\nSorts a list by the results of running each `arr` value through an async `iterator`.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err, sortValue)` which must be called once it\n  has completed with an error (which can be `null`) and a value to use as the sort\n  criteria.\n* `callback(err, results)` - A callback which is called after all the `iterator`\n  functions have finished, or an error occurs. Results is the items from\n  the original `arr` sorted by the values returned by the `iterator` calls.\n\n__Example__\n\n```js\nasync.sortBy(['file1','file2','file3'], function(file, callback){\n    fs.stat(file, function(err, stats){\n        callback(err, stats.mtime);\n    });\n}, function(err, results){\n    // results is now the original array of files sorted by\n    // modified date\n});\n```\n\n__Sort Order__\n\nBy modifying the callback parameter the sorting order can be influenced:\n\n```js\n//ascending order\nasync.sortBy([1,9,3,5], function(x, callback){\n    callback(err, x);\n}, function(err,result){\n    //result callback\n} );\n\n//descending order\nasync.sortBy([1,9,3,5], function(x, callback){\n    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\n}, function(err,result){\n    //result callback\n} );\n```\n\n---------------------------------------\n\n<a name=\"some\" />\n### some(arr, iterator, callback)\n\n__Alias:__ `any`\n\nReturns `true` if at least one element in the `arr` satisfies an async test.\n_The callback for each iterator call only accepts a single argument of `true` or\n`false`; it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like `fs.exists`. Once any iterator\ncall returns `true`, the main `callback` is immediately called.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A truth test to apply to each item in the array\n  in parallel. The iterator is passed a callback(truthValue) which must be \n  called with a boolean argument once it has completed.\n* `callback(result)` - A callback which is called as soon as any iterator returns\n  `true`, or after all the iterator functions have finished. Result will be\n  either `true` or `false` depending on the values of the async tests.\n\n__Example__\n\n```js\nasync.some(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then at least one of the files exists\n});\n```\n\n---------------------------------------\n\n<a name=\"every\" />\n### every(arr, iterator, callback)\n\n__Alias:__ `all`\n\nReturns `true` if every element in `arr` satisfies an async test.\n_The callback for each `iterator` call only accepts a single argument of `true` or\n`false`; it does not accept an error argument first!_ This is in-line with the\nway node libraries work with truth tests like `fs.exists`.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A truth test to apply to each item in the array\n  in parallel. The iterator is passed a callback(truthValue) which must be \n  called with a  boolean argument once it has completed.\n* `callback(result)` - A callback which is called after all the `iterator`\n  functions have finished. Result will be either `true` or `false` depending on\n  the values of the async tests.\n\n__Example__\n\n```js\nasync.every(['file1','file2','file3'], fs.exists, function(result){\n    // if result is true then every file exists\n});\n```\n\n---------------------------------------\n\n<a name=\"concat\" />\n### concat(arr, iterator, callback)\n\nApplies `iterator` to each item in `arr`, concatenating the results. Returns the\nconcatenated list. The `iterator`s are called in parallel, and the results are\nconcatenated as they return. There is no guarantee that the results array will\nbe returned in the original order of `arr` passed to the `iterator` function.\n\n__Arguments__\n\n* `arr` - An array to iterate over.\n* `iterator(item, callback)` - A function to apply to each item in `arr`.\n  The iterator is passed a `callback(err, results)` which must be called once it \n  has completed with an error (which can be `null`) and an array of results.\n* `callback(err, results)` - A callback which is called after all the `iterator`\n  functions have finished, or an error occurs. Results is an array containing\n  the concatenated results of the `iterator` function.\n\n__Example__\n\n```js\nasync.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\n    // files is now a list of filenames that exist in the 3 directories\n});\n```\n\n---------------------------------------\n\n<a name=\"concatSeries\" />\n### concatSeries(arr, iterator, callback)\n\nSame as [`concat`](#concat), but executes in series instead of parallel.\n\n\n## Control Flow\n\n<a name=\"series\" />\n### series(tasks, [callback])\n\nRun the functions in the `tasks` array in series, each one running once the previous\nfunction has completed. If any functions in the series pass an error to its\ncallback, no more functions are run, and `callback` is immediately called with the value of the error. \nOtherwise, `callback` receives an array of results when `tasks` have completed.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function, and the results will be passed to the final `callback` as an object\ninstead of an array. This can be a more readable way of handling results from\n[`series`](#series).\n\n**Note** that while many implementations preserve the order of object properties, the\n[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \nexplicitly states that\n\n> The mechanics and order of enumerating the properties is not specified.\n\nSo if you rely on the order in which your series of functions are executed, and want\nthis to work on all platforms, consider using an array. \n\n__Arguments__\n\n* `tasks` - An array or object containing functions to run, each function is passed\n  a `callback(err, result)` it must call on completion with an error `err` (which can\n  be `null`) and an optional `result` value.\n* `callback(err, results)` - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the `task` callbacks.\n\n__Example__\n\n```js\nasync.series([\n    function(callback){\n        // do some stuff ...\n        callback(null, 'one');\n    },\n    function(callback){\n        // do some more stuff ...\n        callback(null, 'two');\n    }\n],\n// optional callback\nfunction(err, results){\n    // results is now equal to ['one', 'two']\n});\n\n\n// an example using an object instead of an array\nasync.series({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equal to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallel\" />\n### parallel(tasks, [callback])\n\nRun the `tasks` array of functions in parallel, without waiting until the previous\nfunction has completed. If any of the functions pass an error to its\ncallback, the main `callback` is immediately called with the value of the error.\nOnce the `tasks` have completed, the results are passed to the final `callback` as an\narray.\n\nIt is also possible to use an object instead of an array. Each property will be\nrun as a function and the results will be passed to the final `callback` as an object\ninstead of an array. This can be a more readable way of handling results from\n[`parallel`](#parallel).\n\n\n__Arguments__\n\n* `tasks` - An array or object containing functions to run. Each function is passed \n  a `callback(err, result)` which it must call on completion with an error `err` \n  (which can be `null`) and an optional `result` value.\n* `callback(err, results)` - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the task callbacks.\n\n__Example__\n\n```js\nasync.parallel([\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'one');\n        }, 200);\n    },\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'two');\n        }, 100);\n    }\n],\n// optional callback\nfunction(err, results){\n    // the results array will equal ['one','two'] even though\n    // the second function had a shorter timeout.\n});\n\n\n// an example using an object instead of an array\nasync.parallel({\n    one: function(callback){\n        setTimeout(function(){\n            callback(null, 1);\n        }, 200);\n    },\n    two: function(callback){\n        setTimeout(function(){\n            callback(null, 2);\n        }, 100);\n    }\n},\nfunction(err, results) {\n    // results is now equals to: {one: 1, two: 2}\n});\n```\n\n---------------------------------------\n\n<a name=\"parallelLimit\" />\n### parallelLimit(tasks, limit, [callback])\n\nThe same as [`parallel`](#parallel), only `tasks` are executed in parallel \nwith a maximum of `limit` tasks executing at any time.\n\nNote that the `tasks` are not executed in batches, so there is no guarantee that \nthe first `limit` tasks will complete before any others are started.\n\n__Arguments__\n\n* `tasks` - An array or object containing functions to run, each function is passed \n  a `callback(err, result)` it must call on completion with an error `err` (which can\n  be `null`) and an optional `result` value.\n* `limit` - The maximum number of `tasks` to run at any time.\n* `callback(err, results)` - An optional callback to run once all the functions\n  have completed. This function gets a results array (or object) containing all \n  the result arguments passed to the `task` callbacks.\n\n---------------------------------------\n\n<a name=\"whilst\" />\n### whilst(test, fn, callback)\n\nRepeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\nor an error occurs.\n\n__Arguments__\n\n* `test()` - synchronous truth test to perform before each execution of `fn`.\n* `fn(callback)` - A function which is called each time `test` passes. The function is\n  passed a `callback(err)`, which must be called once it has completed with an \n  optional `err` argument.\n* `callback(err)` - A callback which is called after the test fails and repeated\n  execution of `fn` has stopped.\n\n__Example__\n\n```js\nvar count = 0;\n\nasync.whilst(\n    function () { return count < 5; },\n    function (callback) {\n        count++;\n        setTimeout(callback, 1000);\n    },\n    function (err) {\n        // 5 seconds have passed\n    }\n);\n```\n\n---------------------------------------\n\n<a name=\"doWhilst\" />\n### doWhilst(fn, test, callback)\n\nThe post-check version of [`whilst`](#whilst). To reflect the difference in \nthe order of operations, the arguments `test` and `fn` are switched. \n\n`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n\n---------------------------------------\n\n<a name=\"until\" />\n### until(test, fn, callback)\n\nRepeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\nor an error occurs.\n\nThe inverse of [`whilst`](#whilst).\n\n---------------------------------------\n\n<a name=\"doUntil\" />\n### doUntil(fn, test, callback)\n\nLike [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\n\n---------------------------------------\n\n<a name=\"forever\" />\n### forever(fn, errback)\n\nCalls the asynchronous function `fn` with a callback parameter that allows it to\ncall itself again, in series, indefinitely.\n\nIf an error is passed to the callback then `errback` is called with the\nerror, and execution stops, otherwise it will never be called.\n\n```js\nasync.forever(\n    function(next) {\n        // next is suitable for passing to things that need a callback(err [, whatever]);\n        // it will result in this function being called again.\n    },\n    function(err) {\n        // if next is called with a value in its first parameter, it will appear\n        // in here as 'err', and execution will stop.\n    }\n);\n```\n\n---------------------------------------\n\n<a name=\"waterfall\" />\n### waterfall(tasks, [callback])\n\nRuns the `tasks` array of functions in series, each passing their results to the next in\nthe array. However, if any of the `tasks` pass an error to their own callback, the\nnext function is not executed, and the main `callback` is immediately called with\nthe error.\n\n__Arguments__\n\n* `tasks` - An array of functions to run, each function is passed a \n  `callback(err, result1, result2, ...)` it must call on completion. The first\n  argument is an error (which can be `null`) and any further arguments will be \n  passed as arguments in order to the next task.\n* `callback(err, [results])` - An optional callback to run once all the functions\n  have completed. This will be passed the results of the last task's callback.\n\n\n\n__Example__\n\n```js\nasync.waterfall([\n    function(callback){\n        callback(null, 'one', 'two');\n    },\n    function(arg1, arg2, callback){\n      // arg1 now equals 'one' and arg2 now equals 'two'\n        callback(null, 'three');\n    },\n    function(arg1, callback){\n        // arg1 now equals 'three'\n        callback(null, 'done');\n    }\n], function (err, result) {\n   // result now equals 'done'    \n});\n```\n\n---------------------------------------\n<a name=\"compose\" />\n### compose(fn1, fn2...)\n\nCreates a function which is a composition of the passed asynchronous\nfunctions. Each function consumes the return value of the function that\nfollows. Composing functions `f()`, `g()`, and `h()` would produce the result of\n`f(g(h()))`, only this version uses callbacks to obtain the return values.\n\nEach function is executed with the `this` binding of the composed function.\n\n__Arguments__\n\n* `functions...` - the asynchronous functions to compose\n\n\n__Example__\n\n```js\nfunction add1(n, callback) {\n    setTimeout(function () {\n        callback(null, n + 1);\n    }, 10);\n}\n\nfunction mul3(n, callback) {\n    setTimeout(function () {\n        callback(null, n * 3);\n    }, 10);\n}\n\nvar add1mul3 = async.compose(mul3, add1);\n\nadd1mul3(4, function (err, result) {\n   // result now equals 15\n});\n```\n\n---------------------------------------\n<a name=\"seq\" />\n### seq(fn1, fn2...)\n\nVersion of the compose function that is more natural to read.\nEach following function consumes the return value of the latter function. \n\nEach function is executed with the `this` binding of the composed function.\n\n__Arguments__\n\n* functions... - the asynchronous functions to compose\n\n\n__Example__\n\n```js\n// Requires lodash (or underscore), express3 and dresende's orm2.\n// Part of an app, that fetches cats of the logged user.\n// This example uses `seq` function to avoid overnesting and error \n// handling clutter.\napp.get('/cats', function(request, response) {\n  function handleError(err, data, callback) {\n    if (err) {\n      console.error(err);\n      response.json({ status: 'error', message: err.message });\n    }\n    else {\n      callback(data);\n    }\n  }\n  var User = request.models.User;\n  async.seq(\n    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n    handleError,\n    function(user, fn) {\n      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n    },\n    handleError,\n    function(cats) {\n      response.json({ status: 'ok', message: 'Cats found', data: cats });\n    }\n  )(req.session.user_id);\n  }\n});\n```\n\n---------------------------------------\n<a name=\"applyEach\" />\n### applyEach(fns, args..., callback)\n\nApplies the provided arguments to each function in the array, calling \n`callback` after all functions have completed. If you only provide the first\nargument, then it will return a function which lets you pass in the\narguments as if it were a single function call.\n\n__Arguments__\n\n* `fns` - the asynchronous functions to all call with the same arguments\n* `args...` - any number of separate arguments to pass to the function\n* `callback` - the final argument should be the callback, called when all\n  functions have completed processing\n\n\n__Example__\n\n```js\nasync.applyEach([enableSearch, updateSchema], 'bucket', callback);\n\n// partial application example:\nasync.each(\n    buckets,\n    async.applyEach([enableSearch, updateSchema]),\n    callback\n);\n```\n\n---------------------------------------\n\n<a name=\"applyEachSeries\" />\n### applyEachSeries(arr, iterator, callback)\n\nThe same as [`applyEach`](#applyEach) only the functions are applied in series.\n\n---------------------------------------\n\n<a name=\"queue\" />\n### queue(worker, concurrency)\n\nCreates a `queue` object with the specified `concurrency`. Tasks added to the\n`queue` are processed in parallel (up to the `concurrency` limit). If all\n`worker`s are in progress, the task is queued until one becomes available. \nOnce a `worker` completes a `task`, that `task`'s callback is called.\n\n__Arguments__\n\n* `worker(task, callback)` - An asynchronous function for processing a queued\n  task, which must call its `callback(err)` argument when finished, with an \n  optional `error` as an argument.\n* `concurrency` - An `integer` for determining how many `worker` functions should be\n  run in parallel.\n\n__Queue objects__\n\nThe `queue` object returned by this function has the following properties and\nmethods:\n\n* `length()` - a function returning the number of items waiting to be processed.\n* `started` - a function returning whether or not any items have been pushed and processed by the queue\n* `running()` - a function returning the number of items currently being processed.\n* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\n* `concurrency` - an integer for determining how many `worker` functions should be\n  run in parallel. This property can be changed after a `queue` is created to\n  alter the concurrency on-the-fly.\n* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \n  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\n  can be submitted. The respective callback is used for every task in the list.\n* `unshift(task, [callback])` - add a new task to the front of the `queue`.\n* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \n   and further tasks will be queued.\n* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\n* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\n* `paused` - a boolean for determining whether the queue is in a paused state\n* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\n* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\n* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\n\n__Example__\n\n```js\n// create a queue object with concurrency 2\n\nvar q = async.queue(function (task, callback) {\n    console.log('hello ' + task.name);\n    callback();\n}, 2);\n\n\n// assign a callback\nq.drain = function() {\n    console.log('all items have been processed');\n}\n\n// add some items to the queue\n\nq.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\nq.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the queue (batch-wise)\n\nq.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\n    console.log('finished processing bar');\n});\n\n// add some items to the front of the queue\n\nq.unshift({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\n```\n\n\n---------------------------------------\n\n<a name=\"priorityQueue\" />\n### priorityQueue(worker, concurrency)\n\nThe same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\n\n* `push(task, priority, [callback])` - `priority` should be a number. If an array of\n  `tasks` is given, all tasks will be assigned the same priority.\n* The `unshift` method was removed.\n\n---------------------------------------\n\n<a name=\"cargo\" />\n### cargo(worker, [payload])\n\nCreates a `cargo` object with the specified payload. Tasks added to the\ncargo will be processed altogether (up to the `payload` limit). If the\n`worker` is in progress, the task is queued until it becomes available. Once\nthe `worker` has completed some tasks, each callback of those tasks is called.\nCheck out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\n\nWhile [queue](#queue) passes only one task to one of a group of workers\nat a time, cargo passes an array of tasks to a single worker, repeating\nwhen the worker is finished.\n\n__Arguments__\n\n* `worker(tasks, callback)` - An asynchronous function for processing an array of\n  queued tasks, which must call its `callback(err)` argument when finished, with \n  an optional `err` argument.\n* `payload` - An optional `integer` for determining how many tasks should be\n  processed per round; if omitted, the default is unlimited.\n\n__Cargo objects__\n\nThe `cargo` object returned by this function has the following properties and\nmethods:\n\n* `length()` - A function returning the number of items waiting to be processed.\n* `payload` - An `integer` for determining how many tasks should be\n  process per round. This property can be changed after a `cargo` is created to\n  alter the payload on-the-fly.\n* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\n  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \n  can be submitted. The respective callback is used for every task in the list.\n* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\n* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\n* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\n\n__Example__\n\n```js\n// create a cargo object with payload 2\n\nvar cargo = async.cargo(function (tasks, callback) {\n    for(var i=0; i<tasks.length; i++){\n      console.log('hello ' + tasks[i].name);\n    }\n    callback();\n}, 2);\n\n\n// add some items\n\ncargo.push({name: 'foo'}, function (err) {\n    console.log('finished processing foo');\n});\ncargo.push({name: 'bar'}, function (err) {\n    console.log('finished processing bar');\n});\ncargo.push({name: 'baz'}, function (err) {\n    console.log('finished processing baz');\n});\n```\n\n---------------------------------------\n\n<a name=\"auto\" />\n### auto(tasks, [callback])\n\nDetermines the best order for running the functions in `tasks`, based on their \nrequirements. Each function can optionally depend on other functions being completed \nfirst, and each function is run as soon as its requirements are satisfied. \n\nIf any of the functions pass an error to their callback, it will not \ncomplete (so any other functions depending on it will not run), and the main \n`callback` is immediately called with the error. Functions also receive an \nobject containing the results of functions which have completed so far.\n\nNote, all functions are called with a `results` object as a second argument, \nso it is unsafe to pass functions in the `tasks` object which cannot handle the\nextra argument. \n\nFor example, this snippet of code:\n\n```js\nasync.auto({\n  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\n}, callback);\n```\n\nwill have the effect of calling `readFile` with the results object as the last\nargument, which will fail:\n\n```js\nfs.readFile('data.txt', 'utf-8', cb, {});\n```\n\nInstead, wrap the call to `readFile` in a function which does not forward the \n`results` object:\n\n```js\nasync.auto({\n  readData: function(cb, results){\n    fs.readFile('data.txt', 'utf-8', cb);\n  }\n}, callback);\n```\n\n__Arguments__\n\n* `tasks` - An object. Each of its properties is either a function or an array of\n  requirements, with the function itself the last item in the array. The object's key\n  of a property serves as the name of the task defined by that property,\n  i.e. can be used when specifying requirements for other tasks.\n  The function receives two arguments: (1) a `callback(err, result)` which must be \n  called when finished, passing an `error` (which can be `null`) and the result of \n  the function's execution, and (2) a `results` object, containing the results of\n  the previously executed functions.\n* `callback(err, results)` - An optional callback which is called when all the\n  tasks have been completed. It receives the `err` argument if any `tasks` \n  pass an error to their callback. Results are always returned; however, if \n  an error occurs, no further `tasks` will be performed, and the results\n  object will only contain partial results.\n\n\n__Example__\n\n```js\nasync.auto({\n    get_data: function(callback){\n        console.log('in get_data');\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    make_folder: function(callback){\n        console.log('in make_folder');\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    },\n    write_file: ['get_data', 'make_folder', function(callback, results){\n        console.log('in write_file', JSON.stringify(results));\n        // once there is some data and the directory exists,\n        // write the data to a file in the directory\n        callback(null, 'filename');\n    }],\n    email_link: ['write_file', function(callback, results){\n        console.log('in email_link', JSON.stringify(results));\n        // once the file is written let's email a link to it...\n        // results.write_file contains the filename returned by write_file.\n        callback(null, {'file':results.write_file, 'email':'user@example.com'});\n    }]\n}, function(err, results) {\n    console.log('err = ', err);\n    console.log('results = ', results);\n});\n```\n\nThis is a fairly trivial example, but to do this using the basic parallel and\nseries functions would look like this:\n\n```js\nasync.parallel([\n    function(callback){\n        console.log('in get_data');\n        // async code to get some data\n        callback(null, 'data', 'converted to array');\n    },\n    function(callback){\n        console.log('in make_folder');\n        // async code to create a directory to store a file in\n        // this is run at the same time as getting the data\n        callback(null, 'folder');\n    }\n],\nfunction(err, results){\n    async.series([\n        function(callback){\n            console.log('in write_file', JSON.stringify(results));\n            // once there is some data and the directory exists,\n            // write the data to a file in the directory\n            results.push('filename');\n            callback(null);\n        },\n        function(callback){\n            console.log('in email_link', JSON.stringify(results));\n            // once the file is written let's email a link to it...\n            callback(null, {'file':results.pop(), 'email':'user@example.com'});\n        }\n    ]);\n});\n```\n\nFor a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\nnew tasks much easier (and the code more readable).\n\n\n---------------------------------------\n\n<a name=\"retry\" />\n### retry([times = 5], task, [callback])\n\nAttempts to get a successful response from `task` no more than `times` times before\nreturning an error. If the task is successful, the `callback` will be passed the result\nof the successfull task. If all attemps fail, the callback will be passed the error and\nresult (if any) of the final attempt.\n\n__Arguments__\n\n* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\n* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\n  which must be called when finished, passing `err` (which can be `null`) and the `result` of \n  the function's execution, and (2) a `results` object, containing the results of\n  the previously executed functions (if nested inside another control flow).\n* `callback(err, results)` - An optional callback which is called when the\n  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\n\nThe [`retry`](#retry) function can be used as a stand-alone control flow by passing a\ncallback, as shown below:\n\n```js\nasync.retry(3, apiMethod, function(err, result) {\n    // do something with the result\n});\n```\n\nIt can also be embeded within other control flow functions to retry individual methods\nthat are not as reliable, like this:\n\n```js\nasync.auto({\n    users: api.getUsers.bind(api),\n    payments: async.retry(3, api.getPayments.bind(api))\n}, function(err, results) {\n  // do something with the results\n});\n```\n\n\n---------------------------------------\n\n<a name=\"iterator\" />\n### iterator(tasks)\n\nCreates an iterator function which calls the next function in the `tasks` array,\nreturning a continuation to call the next one after that. It's also possible to\n“peek” at the next iterator with `iterator.next()`.\n\nThis function is used internally by the `async` module, but can be useful when\nyou want to manually control the flow of functions in series.\n\n__Arguments__\n\n* `tasks` - An array of functions to run.\n\n__Example__\n\n```js\nvar iterator = async.iterator([\n    function(){ sys.p('one'); },\n    function(){ sys.p('two'); },\n    function(){ sys.p('three'); }\n]);\n\nnode> var iterator2 = iterator();\n'one'\nnode> var iterator3 = iterator2();\n'two'\nnode> iterator3();\n'three'\nnode> var nextfn = iterator2.next();\nnode> nextfn();\n'three'\n```\n\n---------------------------------------\n\n<a name=\"apply\" />\n### apply(function, arguments..)\n\nCreates a continuation function with some arguments already applied. \n\nUseful as a shorthand when combined with other control flow functions. Any arguments\npassed to the returned function are added to the arguments originally passed\nto apply.\n\n__Arguments__\n\n* `function` - The function you want to eventually apply all arguments to.\n* `arguments...` - Any number of arguments to automatically apply when the\n  continuation is called.\n\n__Example__\n\n```js\n// using apply\n\nasync.parallel([\n    async.apply(fs.writeFile, 'testfile1', 'test1'),\n    async.apply(fs.writeFile, 'testfile2', 'test2'),\n]);\n\n\n// the same process without using apply\n\nasync.parallel([\n    function(callback){\n        fs.writeFile('testfile1', 'test1', callback);\n    },\n    function(callback){\n        fs.writeFile('testfile2', 'test2', callback);\n    }\n]);\n```\n\nIt's possible to pass any number of additional arguments when calling the\ncontinuation:\n\n```js\nnode> var fn = async.apply(sys.puts, 'one');\nnode> fn('two', 'three');\none\ntwo\nthree\n```\n\n---------------------------------------\n\n<a name=\"nextTick\" />\n### nextTick(callback)\n\nCalls `callback` on a later loop around the event loop. In Node.js this just\ncalls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\nif available, otherwise `setTimeout(callback, 0)`, which means other higher priority\nevents may precede the execution of `callback`.\n\nThis is used internally for browser-compatibility purposes.\n\n__Arguments__\n\n* `callback` - The function to call on a later loop around the event loop.\n\n__Example__\n\n```js\nvar call_order = [];\nasync.nextTick(function(){\n    call_order.push('two');\n    // call_order now equals ['one','two']\n});\ncall_order.push('one')\n```\n\n<a name=\"times\" />\n### times(n, callback)\n\nCalls the `callback` function `n` times, and accumulates results in the same manner\nyou would use with [`map`](#map).\n\n__Arguments__\n\n* `n` - The number of times to run the function.\n* `callback` - The function to call `n` times.\n\n__Example__\n\n```js\n// Pretend this is some complicated async factory\nvar createUser = function(id, callback) {\n  callback(null, {\n    id: 'user' + id\n  })\n}\n// generate 5 users\nasync.times(5, function(n, next){\n    createUser(n, function(err, user) {\n      next(err, user)\n    })\n}, function(err, users) {\n  // we should now have 5 users\n});\n```\n\n<a name=\"timesSeries\" />\n### timesSeries(n, callback)\n\nThe same as [`times`](#times), only the iterator is applied to each item in `arr` in\nseries. The next `iterator` is only called once the current one has completed. \nThe results array will be in the same order as the original.\n\n\n## Utils\n\n<a name=\"memoize\" />\n### memoize(fn, [hasher])\n\nCaches the results of an `async` function. When creating a hash to store function\nresults against, the callback is omitted from the hash and an optional hash\nfunction can be used.\n\nThe cache of results is exposed as the `memo` property of the function returned\nby `memoize`.\n\n__Arguments__\n\n* `fn` - The function to proxy and cache results from.\n* `hasher` - Tn optional function for generating a custom hash for storing\n  results. It has all the arguments applied to it apart from the callback, and\n  must be synchronous.\n\n__Example__\n\n```js\nvar slow_fn = function (name, callback) {\n    // do something\n    callback(null, result);\n};\nvar fn = async.memoize(slow_fn);\n\n// fn can now be used as if it were slow_fn\nfn('some name', function () {\n    // callback\n});\n```\n\n<a name=\"unmemoize\" />\n### unmemoize(fn)\n\nUndoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\nform. Handy for testing.\n\n__Arguments__\n\n* `fn` - the memoized function\n\n<a name=\"log\" />\n### log(function, arguments)\n\nLogs the result of an `async` function to the `console`. Only works in Node.js or\nin browsers that support `console.log` and `console.error` (such as FF and Chrome).\nIf multiple arguments are returned from the async function, `console.log` is\ncalled on each argument in order.\n\n__Arguments__\n\n* `function` - The function you want to eventually apply all arguments to.\n* `arguments...` - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, 'hello ' + name);\n    }, 1000);\n};\n```\n```js\nnode> async.log(hello, 'world');\n'hello world'\n```\n\n---------------------------------------\n\n<a name=\"dir\" />\n### dir(function, arguments)\n\nLogs the result of an `async` function to the `console` using `console.dir` to\ndisplay the properties of the resulting object. Only works in Node.js or\nin browsers that support `console.dir` and `console.error` (such as FF and Chrome).\nIf multiple arguments are returned from the async function, `console.dir` is\ncalled on each argument in order.\n\n__Arguments__\n\n* `function` - The function you want to eventually apply all arguments to.\n* `arguments...` - Any number of arguments to apply to the function.\n\n__Example__\n\n```js\nvar hello = function(name, callback){\n    setTimeout(function(){\n        callback(null, {hello: name});\n    }, 1000);\n};\n```\n```js\nnode> async.dir(hello, 'world');\n{hello: 'world'}\n```\n\n---------------------------------------\n\n<a name=\"noConflict\" />\n### noConflict()\n\nChanges the value of `async` back to its original value, returning a reference to the\n`async` object.\n",
   39    "readmeFilename": "README.md",
   40    "homepage": "https://github.com/caolan/async",

/Users/student/Desktop/2014-09-databases/node_modules/request/node_modules/form-data/node_modules/async/README.md:
  789
  790  The same as [`parallel`](#parallel), only `tasks` are executed in parallel
  791: with a maximum of `limit` tasks executing at any time.
  792
  793  Note that the `tasks` are not executed in batches, so there is no guarantee that

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/query-chainer.js:
   83
   84    /**
   85:    * Run the query chainer. In reality, this means, wait for all the added emtiters to finish, since the queries began executing as soon as you invoked their methods.
   86     * @return {EventEmitter}
   87     */

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/sequelize.js:
   75     * @param {Function} [options.logging=console.log] A function that gets executed everytime Sequelize would log something.
   76     * @param {Boolean}  [options.omitNull=false] A flag that defines if null values should be passed to SQL queries or not.
   77:    * @param {Boolean}  [options.queue=true] Queue queries, so that only maxConcurrentQueries number of queries are executing at once. If false, all queries will be executed immediately.
   78     * @param {Integer}  [options.maxConcurrentQueries=50] The maximum number of queries that should be executed at once if queue is true.
   79     * @param {Boolean}  [options.native=false] A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   ..
  527     * @param {Boolean}       [options.raw] If true, sequelize will not try to format the results of the query, or build an instance of a model from the result
  528     * @param {Transaction}   [options.transaction=null] The transaction that the query should be executed under
  529:    * @param {String}        [options.type='SELECT'] The type of query you are executing. The query type affects how results are formatted before they are passed back. If no type is provided sequelize will try to guess the right type based on the sql, and fall back to SELECT. The type is a string, but `Sequelize.QueryTypes` is provided is convenience shortcuts. Current options are SELECT, BULKUPDATE and BULKDELETE
  530     * @param {Boolean}       [options.nest=false] If true, transforms objects with `.` separated property names into nested objects using [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes { user: { username: 'john' }}
  531     * @param {Object|Array}  [replacements] Either an object of named parameter replacements in the format `:param` or an array of unnamed replacements to replace `?` in your SQL.

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/dialects/mariadb/query.js:
   28
   29      if (this.options.logging !== false) {
   30:       this.sequelize.log('Executing (' + this.client.uuid + '): ' + this.sql);
   31      }
   32

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/dialects/mysql/query.js:
   28
   29      if (this.options.logging !== false) {
   30:       this.sequelize.log('Executing (' + (this.connection.uuid || 'default') + '): ' + this.sql);
   31      }
   32

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/dialects/postgres/query.js:
   49
   50      if (this.options.logging !== false) {
   51:       this.sequelize.log('Executing (' + (this.client.uuid || 'default') + '): ' + this.sql);
   52      }
   53

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/lib/dialects/sqlite/query.js:
   32
   33      if (this.options.logging !== false) {
   34:       this.sequelize.log('Executing (' + (this.database.uuid || 'default') + '): ' + this.sql);
   35      }
   36

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/lodash/lodash.js:
 2036      /**
 2037       * A function compiled to iterate `arguments` objects, arrays, objects, and
 2038:      * strings consistenly across environments, executing the callback for each
 2039       * element in the collection. The callback is bound to `thisArg` and invoked
 2040       * with three arguments; (value, index|key, collection). Callbacks may exit
 ....
 2357      /**
 2358       * Iterates over own and inherited enumerable properties of an object,
 2359:      * executing the callback for each property. The callback is bound to `thisArg`
 2360       * and invoked with three arguments; (value, key, object). Callbacks may exit
 2361       * iteration early by explicitly returning `false`.
 ....
 2436
 2437      /**
 2438:      * Iterates over own enumerable properties of an object, executing the callback
 2439       * for each property. The callback is bound to `thisArg` and invoked with three
 2440       * arguments; (value, key, object). Callbacks may exit iteration early by
 ....
 3623
 3624      /**
 3625:      * Iterates over elements of a collection, executing the callback for each
 3626       * element. The callback is bound to `thisArg` and invoked with three arguments;
 3627       * (value, index|key, collection). Callbacks may exit iteration early by
 ....
 5841
 5842      /**
 5843:      * Defers executing the `func` function until the current call stack has cleared.
 5844       * Additional arguments will be provided to `func` when it is invoked.
 5845       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/lodash/dist/lodash.compat.js:
 2019      /**
 2020       * A function compiled to iterate `arguments` objects, arrays, objects, and
 2021:      * strings consistenly across environments, executing the callback for each
 2022       * element in the collection. The callback is bound to `thisArg` and invoked
 2023       * with three arguments; (value, index|key, collection). Callbacks may exit
 ....
 2340      /**
 2341       * Iterates over own and inherited enumerable properties of an object,
 2342:      * executing the callback for each property. The callback is bound to `thisArg`
 2343       * and invoked with three arguments; (value, key, object). Callbacks may exit
 2344       * iteration early by explicitly returning `false`.
 ....
 2419
 2420      /**
 2421:      * Iterates over own enumerable properties of an object, executing the callback
 2422       * for each property. The callback is bound to `thisArg` and invoked with three
 2423       * arguments; (value, key, object). Callbacks may exit iteration early by
 ....
 3606
 3607      /**
 3608:      * Iterates over elements of a collection, executing the callback for each
 3609       * element. The callback is bound to `thisArg` and invoked with three arguments;
 3610       * (value, index|key, collection). Callbacks may exit iteration early by
 ....
 5824
 5825      /**
 5826:      * Defers executing the `func` function until the current call stack has cleared.
 5827       * Additional arguments will be provided to `func` when it is invoked.
 5828       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/lodash/dist/lodash.js:
 1986      /**
 1987       * Iterates over own and inherited enumerable properties of an object,
 1988:      * executing the callback for each property. The callback is bound to `thisArg`
 1989       * and invoked with three arguments; (value, key, object). Callbacks may exit
 1990       * iteration early by explicitly returning `false`.
 ....
 2072
 2073      /**
 2074:      * Iterates over own enumerable properties of an object, executing the callback
 2075       * for each property. The callback is bound to `thisArg` and invoked with three
 2076       * arguments; (value, key, object). Callbacks may exit iteration early by
 ....
 3263
 3264      /**
 3265:      * Iterates over elements of a collection, executing the callback for each
 3266       * element. The callback is bound to `thisArg` and invoked with three arguments;
 3267       * (value, index|key, collection). Callbacks may exit iteration early by
 ....
 5474
 5475      /**
 5476:      * Defers executing the `func` function until the current call stack has cleared.
 5477       * Additional arguments will be provided to `func` when it is invoked.
 5478       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/lodash/dist/lodash.underscore.js:
 1135    /**
 1136     * Iterates over own and inherited enumerable properties of an object,
 1137:    * executing the callback for each property. The callback is bound to `thisArg`
 1138     * and invoked with three arguments; (value, key, object). Callbacks may exit
 1139     * iteration early by explicitly returning `false`.
 ....
 1175
 1176    /**
 1177:    * Iterates over own enumerable properties of an object, executing the callback
 1178     * for each property. The callback is bound to `thisArg` and invoked with three
 1179     * arguments; (value, key, object). Callbacks may exit iteration early by
 ....
 2054
 2055    /**
 2056:    * Iterates over elements of a collection, executing the callback for each
 2057     * element. The callback is bound to `thisArg` and invoked with three arguments;
 2058     * (value, index|key, collection). Callbacks may exit iteration early by
 ....
 3931
 3932    /**
 3933:    * Defers executing the `func` function until the current call stack has cleared.
 3934     * Additional arguments will be provided to `func` when it is invoked.
 3935     *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/lodash.js:
 1294      /**
 1295       * A function compiled to iterate `arguments` objects, arrays, objects, and
 1296:      * strings consistenly across environments, executing the `callback` for each
 1297       * element in the `collection`. The `callback` is bound to `thisArg` and invoked
 1298       * with three arguments; (value, index|key, collection). Callbacks may exit
 ....
 1603
 1604      /**
 1605:      * Iterates over `object`'s own and inherited enumerable properties, executing
 1606       * the `callback` for each property. The `callback` is bound to `thisArg` and
 1607       * invoked with three arguments; (value, key, object). Callbacks may exit iteration
 ....
 1636
 1637      /**
 1638:      * Iterates over an object's own enumerable properties, executing the `callback`
 1639       * for each property. The `callback` is bound to `thisArg` and invoked with three
 1640       * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
 ....
 2924
 2925      /**
 2926:      * Iterates over a `collection`, executing the `callback` for each element in
 2927       * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 2928       * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 4544      /**
 4545       * If `n` is greater than `0`, a function is created that is restricted to
 4546:      * executing `func`, with the `this` binding and arguments of the created
 4547       * function, only after it is called `n` times. If `n` is less than `1`,
 4548       * `func` is executed immediately, without a `this` binding or additional
 ....
 4916
 4917      /**
 4918:      * Defers executing the `func` function until the current call stack has cleared.
 4919       * Additional arguments will be passed to `func` when it is invoked.
 4920       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/dist/lodash.compat.js:
 1275      /**
 1276       * A function compiled to iterate `arguments` objects, arrays, objects, and
 1277:      * strings consistenly across environments, executing the `callback` for each
 1278       * element in the `collection`. The `callback` is bound to `thisArg` and invoked
 1279       * with three arguments; (value, index|key, collection). Callbacks may exit
 ....
 1584
 1585      /**
 1586:      * Iterates over `object`'s own and inherited enumerable properties, executing
 1587       * the `callback` for each property. The `callback` is bound to `thisArg` and
 1588       * invoked with three arguments; (value, key, object). Callbacks may exit iteration
 ....
 1617
 1618      /**
 1619:      * Iterates over an object's own enumerable properties, executing the `callback`
 1620       * for each property. The `callback` is bound to `thisArg` and invoked with three
 1621       * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
 ....
 2905
 2906      /**
 2907:      * Iterates over a `collection`, executing the `callback` for each element in
 2908       * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 2909       * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 4525      /**
 4526       * If `n` is greater than `0`, a function is created that is restricted to
 4527:      * executing `func`, with the `this` binding and arguments of the created
 4528       * function, only after it is called `n` times. If `n` is less than `1`,
 4529       * `func` is executed immediately, without a `this` binding or additional
 ....
 4897
 4898      /**
 4899:      * Defers executing the `func` function until the current call stack has cleared.
 4900       * Additional arguments will be passed to `func` when it is invoked.
 4901       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/dist/lodash.js:
 1228
 1229      /**
 1230:      * Iterates over `object`'s own and inherited enumerable properties, executing
 1231       * the `callback` for each property. The `callback` is bound to `thisArg` and
 1232       * invoked with three arguments; (value, key, object). Callbacks may exit iteration
 ....
 1268
 1269      /**
 1270:      * Iterates over an object's own enumerable properties, executing the `callback`
 1271       * for each property. The `callback` is bound to `thisArg` and invoked with three
 1272       * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
 ....
 2560
 2561      /**
 2562:      * Iterates over a `collection`, executing the `callback` for each element in
 2563       * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 2564       * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 4190      /**
 4191       * If `n` is greater than `0`, a function is created that is restricted to
 4192:      * executing `func`, with the `this` binding and arguments of the created
 4193       * function, only after it is called `n` times. If `n` is less than `1`,
 4194       * `func` is executed immediately, without a `this` binding or additional
 ....
 4562
 4563      /**
 4564:      * Defers executing the `func` function until the current call stack has cleared.
 4565       * Additional arguments will be passed to `func` when it is invoked.
 4566       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/dist/lodash.legacy.js:
 1153      /**
 1154       * A function compiled to iterate `arguments` objects, arrays, objects, and
 1155:      * strings consistenly across environments, executing the `callback` for each
 1156       * element in the `collection`. The `callback` is bound to `thisArg` and invoked
 1157       * with three arguments; (value, index|key, collection). Callbacks may exit
 ....
 1462
 1463      /**
 1464:      * Iterates over `object`'s own and inherited enumerable properties, executing
 1465       * the `callback` for each property. The `callback` is bound to `thisArg` and
 1466       * invoked with three arguments; (value, key, object). Callbacks may exit iteration
 ....
 1495
 1496      /**
 1497:      * Iterates over an object's own enumerable properties, executing the `callback`
 1498       * for each property. The `callback` is bound to `thisArg` and invoked with three
 1499       * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
 ....
 2801
 2802      /**
 2803:      * Iterates over a `collection`, executing the `callback` for each element in
 2804       * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 2805       * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 4421      /**
 4422       * If `n` is greater than `0`, a function is created that is restricted to
 4423:      * executing `func`, with the `this` binding and arguments of the created
 4424       * function, only after it is called `n` times. If `n` is less than `1`,
 4425       * `func` is executed immediately, without a `this` binding or additional
 ....
 4788
 4789      /**
 4790:      * Defers executing the `func` function until the current call stack has cleared.
 4791       * Additional arguments will be passed to `func` when it is invoked.
 4792       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/dist/lodash.mobile.js:
  956      /**
  957       * A function compiled to iterate `arguments` objects, arrays, objects, and
  958:      * strings consistenly across environments, executing the `callback` for each
  959       * element in the `collection`. The `callback` is bound to `thisArg` and invoked
  960       * with three arguments; (value, index|key, collection). Callbacks may exit
  ...
 1333
 1334      /**
 1335:      * Iterates over `object`'s own and inherited enumerable properties, executing
 1336       * the `callback` for each property. The `callback` is bound to `thisArg` and
 1337       * invoked with three arguments; (value, key, object). Callbacks may exit iteration
 ....
 1385
 1386      /**
 1387:      * Iterates over an object's own enumerable properties, executing the `callback`
 1388       * for each property. The `callback` is bound to `thisArg` and invoked with three
 1389       * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
 ....
 2690
 2691      /**
 2692:      * Iterates over a `collection`, executing the `callback` for each element in
 2693       * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 2694       * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 4306      /**
 4307       * If `n` is greater than `0`, a function is created that is restricted to
 4308:      * executing `func`, with the `this` binding and arguments of the created
 4309       * function, only after it is called `n` times. If `n` is less than `1`,
 4310       * `func` is executed immediately, without a `this` binding or additional
 ....
 4678
 4679      /**
 4680:      * Defers executing the `func` function until the current call stack has cleared.
 4681       * Additional arguments will be passed to `func` when it is invoked.
 4682       *

/Users/student/Desktop/2014-09-databases/node_modules/sequelize/node_modules/sql/node_modules/lodash/dist/lodash.underscore.js:
  746
  747    /**
  748:    * Iterates over `object`'s own and inherited enumerable properties, executing
  749     * the `callback` for each property. The `callback` is bound to `thisArg` and
  750     * invoked with three arguments; (value, key, object). Callbacks may exit iteration
  ...
  785
  786    /**
  787:    * Iterates over an object's own enumerable properties, executing the `callback`
  788     * for each property. The `callback` is bound to `thisArg` and invoked with three
  789     * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
  ...
 1754
 1755    /**
 1756:    * Iterates over a `collection`, executing the `callback` for each element in
 1757     * the `collection`. The `callback` is bound to `thisArg` and invoked with three
 1758     * arguments; (value, index|key, collection). Callbacks may exit iteration early
 ....
 3311    /**
 3312     * If `n` is greater than `0`, a function is created that is restricted to
 3313:    * executing `func`, with the `this` binding and arguments of the created
 3314     * function, only after it is called `n` times. If `n` is less than `1`,
 3315     * `func` is executed immediately, without a `this` binding or additional
 ....
 3590
 3591    /**
 3592:    * Defers executing the `func` function until the current call stack has cleared.
 3593     * Additional arguments will be passed to `func` when it is invoked.
 3594     *

/Users/student/Desktop/2014-09-databases/ORM_Refactor/spec/ServerSpec.js:
    5
    6  // Conditional async testing, akin to Jasmine's waitsFor()
    7: // Will wait for test to be truthy before executing callback
    8  function waitForThen(test, cb) {
    9    setTimeout(function() {

77 matches across 29 files
